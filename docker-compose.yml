version: '3.1'

services:
  authorizer:
    #    image: acantu297366/authorizer
    container_name: "authorizer"
    build: "./authorizer"
    depends_on:
      postgres:
        condition: service_healthy
    ports:
      - ${AUTH_PORT}:${AUTH_PORT}
    env_file:
      - .env
    networks:
      - microservices

  candidate:
    #    image: acantu297366/candidate
    container_name: "candidate"
    build: "./candidate"
    depends_on:
      postgres:
        condition: service_healthy
    ports:
      - ${CANDIDATE_PORT}:${CANDIDATE_PORT}
    env_file:
      - .env
    networks:
      - microservices

  company:
    #    image: acantu297366/company
    container_name: "company"
    build: "./company"
    depends_on:
      postgres:
        condition: service_healthy
    ports:
      - ${COMPANY_PORT}:${COMPANY_PORT}
    env_file:
      - .env
    networks:
      - microservices

  project:
    #    image: acantu297366/project
    container_name: "project"
    build: "./project"
    depends_on:
      postgres:
        condition: service_healthy
    ports:
      - ${PROJECT_PORT}:${PROJECT_PORT}
    env_file:
      - .env
    networks:
      - microservices

  postgres:
    container_name: "postgres"
    image: postgres:15.4-alpine3.18
    restart: always
    env_file:
      - .env
    networks:
      - microservices
    ports:
      - ${POSTGRES_PORT}:${POSTGRES_PORT}
    healthcheck:
      test: [ "CMD", "pg_isready", "-U", "postgres" ]
      interval: 2s
      timeout: 30s
      retries: 5

  api:
    #    image: acantu297366/api
    container_name: "api"
    build: "./api"
    networks:
      - microservices
    ports:
      - ${API_PORT}:${API_PORT}
    env_file:
      - .env
    depends_on:
      - authorizer
      - candidate
      - company
      - project
      - postgres

networks:
  microservices:
    driver: bridge
